# ç®—æ³•å…¬å¼€è¯¾

**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[ç»„åˆä¸æ’åˆ—çš„åŒºåˆ«ï¼Œå›æº¯ç®—æ³•æ±‚è§£çš„æ—¶å€™ï¼Œæœ‰ä½•ä¸åŒï¼Ÿ| LeetCodeï¼š46.å…¨æ’åˆ—](https://www.bilibili.com/video/BV19v4y1S79W/)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

## æ€è·¯

æ­¤æ—¶æˆ‘ä»¬å·²ç»å­¦ä¹ äº†[77.ç»„åˆé—®é¢˜](https://programmercarl.com/0077.ç»„åˆ.html)ã€ [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)å’Œ[78.å­é›†é—®é¢˜](https://programmercarl.com/0078.å­é›†.html)ï¼Œæ¥ä¸‹æ¥çœ‹ä¸€çœ‹æ’åˆ—é—®é¢˜ã€‚

ç›¸ä¿¡è¿™ä¸ªæ’åˆ—é—®é¢˜å°±ç®—æ˜¯è®©ä½ ç”¨forå¾ªç¯æš´åŠ›æŠŠç»“æœæœç´¢å‡ºæ¥ï¼Œè¿™ä¸ªæš´åŠ›ä¹Ÿä¸æ˜¯å¾ˆå¥½å†™ã€‚

æ‰€ä»¥æ­£å¦‚æˆ‘ä»¬åœ¨[å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)æ‰€è®²çš„ä¸ºä»€ä¹ˆå›æº¯æ³•æ˜¯æš´åŠ›æœç´¢ï¼Œæ•ˆç‡è¿™ä¹ˆä½ï¼Œè¿˜è¦ç”¨å®ƒï¼Ÿ

**å› ä¸ºä¸€äº›é—®é¢˜èƒ½æš´åŠ›æœå‡ºæ¥å°±å·²ç»å¾ˆä¸é”™äº†ï¼**

æˆ‘ä»¥[1,2,3]ä¸ºä¾‹ï¼ŒæŠ½è±¡æˆæ ‘å½¢ç»“æ„å¦‚ä¸‹ï¼š

![image.png](https://pic.leetcode.cn/1674875632-abWPjF-image.png)

### å›æº¯ä¸‰éƒ¨æ›²

* é€’å½’å‡½æ•°å‚æ•°

**é¦–å…ˆæ’åˆ—æ˜¯æœ‰åºçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ [1,2] å’Œ [2,1] æ˜¯ä¸¤ä¸ªé›†åˆï¼Œè¿™å’Œä¹‹å‰åˆ†æçš„å­é›†ä»¥åŠç»„åˆæ‰€ä¸åŒçš„åœ°æ–¹**ã€‚

å¯ä»¥çœ‹å‡ºå…ƒç´ 1åœ¨[1,2]ä¸­å·²ç»ä½¿ç”¨è¿‡äº†ï¼Œä½†æ˜¯åœ¨[2,1]ä¸­è¿˜è¦åœ¨ä½¿ç”¨ä¸€æ¬¡1ï¼Œæ‰€ä»¥å¤„ç†æ’åˆ—é—®é¢˜å°±ä¸ç”¨ä½¿ç”¨startIndexäº†ã€‚

ä½†æ’åˆ—é—®é¢˜éœ€è¦ä¸€ä¸ªusedæ•°ç»„ï¼Œæ ‡è®°å·²ç»é€‰æ‹©çš„å…ƒç´ ï¼Œå¦‚å›¾æ©˜é»„è‰²éƒ¨åˆ†æ‰€ç¤º:

![image.png](https://pic.leetcode.cn/1674875664-WFuENf-image.png)

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
vector<vector<int>> result;
vector<int> path;
void backtracking (vector<int>& nums, vector<bool>& used)
```

* é€’å½’ç»ˆæ­¢æ¡ä»¶

![image.png](https://pic.leetcode.cn/1674875664-WFuENf-image.png)

å¯ä»¥çœ‹å‡ºå¶å­èŠ‚ç‚¹ï¼Œå°±æ˜¯æ”¶å‰²ç»“æœçš„åœ°æ–¹ã€‚

é‚£ä¹ˆä»€ä¹ˆæ—¶å€™ï¼Œç®—æ˜¯åˆ°è¾¾å¶å­èŠ‚ç‚¹å‘¢ï¼Ÿ

å½“æ”¶é›†å…ƒç´ çš„æ•°ç»„pathçš„å¤§å°è¾¾åˆ°å’Œnumsæ•°ç»„ä¸€æ ·å¤§çš„æ—¶å€™ï¼Œè¯´æ˜æ‰¾åˆ°äº†ä¸€ä¸ªå…¨æ’åˆ—ï¼Œä¹Ÿè¡¨ç¤ºåˆ°è¾¾äº†å¶å­èŠ‚ç‚¹ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
// æ­¤æ—¶è¯´æ˜æ‰¾åˆ°äº†ä¸€ç»„
if (path.size() == nums.size()) {
    result.push_back(path);
    return;
}
```

* å•å±‚æœç´¢çš„é€»è¾‘

è¿™é‡Œå’Œ[77.ç»„åˆé—®é¢˜](https://programmercarl.com/0077.ç»„åˆ.html)ã€[131.åˆ‡å‰²é—®é¢˜](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)å’Œ[78.å­é›†é—®é¢˜](https://programmercarl.com/0078.å­é›†.html)æœ€å¤§çš„ä¸åŒå°±æ˜¯forå¾ªç¯é‡Œä¸ç”¨startIndexäº†ã€‚

å› ä¸ºæ’åˆ—é—®é¢˜ï¼Œæ¯æ¬¡éƒ½è¦ä»å¤´å¼€å§‹æœç´¢ï¼Œä¾‹å¦‚å…ƒç´ 1åœ¨[1,2]ä¸­å·²ç»ä½¿ç”¨è¿‡äº†ï¼Œä½†æ˜¯åœ¨[2,1]ä¸­è¿˜è¦å†ä½¿ç”¨ä¸€æ¬¡1ã€‚

**è€Œusedæ•°ç»„ï¼Œå…¶å®å°±æ˜¯è®°å½•æ­¤æ—¶pathé‡Œéƒ½æœ‰å“ªäº›å…ƒç´ ä½¿ç”¨äº†ï¼Œä¸€ä¸ªæ’åˆ—é‡Œä¸€ä¸ªå…ƒç´ åªèƒ½ä½¿ç”¨ä¸€æ¬¡**ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
for (int i = 0; i < nums.size(); i++) {
    if (used[i] == true) continue; // pathé‡Œå·²ç»æ”¶å½•çš„å…ƒç´ ï¼Œç›´æ¥è·³è¿‡
    used[i] = true;
    path.push_back(nums[i]);
    backtracking(nums, used);
    path.pop_back();
    used[i] = false;
}
```

æ•´ä½“C++ä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        // æ­¤æ—¶è¯´æ˜æ‰¾åˆ°äº†ä¸€ç»„
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == true) continue; // pathé‡Œå·²ç»æ”¶å½•çš„å…ƒç´ ï¼Œç›´æ¥è·³è¿‡
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

## æ€»ç»“

å¤§å®¶æ­¤æ—¶å¯ä»¥æ„Ÿå—å‡ºæ’åˆ—é—®é¢˜çš„ä¸åŒï¼š

* æ¯å±‚éƒ½æ˜¯ä»0å¼€å§‹æœç´¢è€Œä¸æ˜¯startIndex
* éœ€è¦usedæ•°ç»„è®°å½•pathé‡Œéƒ½æ”¾äº†å“ªäº›å…ƒç´ äº†

æ’åˆ—é—®é¢˜æ˜¯å›æº¯ç®—æ³•è§£å†³çš„ç»å…¸é¢˜ç›®ï¼Œå¤§å®¶å¯ä»¥å¥½å¥½ä½“ä¼šä½“ä¼šã€‚

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();// å­˜æ”¾ç¬¦åˆæ¡ä»¶ç»“æœçš„é›†åˆ
    LinkedList<Integer> path = new LinkedList<>();// ç”¨æ¥å­˜æ”¾ç¬¦åˆæ¡ä»¶ç»“æœ
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0){
            return result;
        }
        used = new boolean[nums.length];
        permuteHelper(nums);
        return result;
    }

    private void permuteHelper(int[] nums){
        if (path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++){
            if (used[i]){
                continue;
            }
            used[i] = true;
            path.add(nums[i]);
            permuteHelper(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}

// è§£æ³•2ï¼šé€šè¿‡åˆ¤æ–­pathä¸­æ˜¯å¦å­˜åœ¨æ•°å­—ï¼Œæ’é™¤å·²ç»é€‰æ‹©çš„æ•°å­—
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length == 0) return result;
        backtrack(nums, path);
        return result;
    }
    public void backtrack(int[] nums, LinkedList<Integer> path) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
        }
        for (int i =0; i < nums.length; i++) {
            // å¦‚æœpathä¸­å·²æœ‰ï¼Œåˆ™è·³è¿‡
            if (path.contains(nums[i])) {
                continue;
            } 
            path.add(nums[i]);
            backtrack(nums, path);
            path.removeLast();
        }
    }
}
```

* []

```python
# **å›æº¯**
class Solution:
    def __init__(self):
        self.path = []
        self.paths = []

    def permute(self, nums: List[int]) -> List[List[int]]:
        '''
        å› ä¸ºæœ¬é¢˜æ’åˆ—æ˜¯æœ‰åºçš„ï¼Œè¿™æ„å‘³ç€åŒä¸€å±‚çš„å…ƒç´ å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä½†åŒä¸€æ ‘æä¸Šä¸èƒ½é‡å¤ä½¿ç”¨(usage_list)
        æ‰€ä»¥å¤„ç†æ’åˆ—é—®é¢˜æ¯å±‚éƒ½éœ€è¦ä»å¤´æœç´¢ï¼Œæ•…ä¸å†ä½¿ç”¨start_index
        '''
        usage_list = [False] * len(nums)
        self.backtracking(nums, usage_list)
        return self.paths

    def backtracking(self, nums: List[int], usage_list: List[bool]) -> None:
        # Base Caseæœ¬é¢˜æ±‚å¶å­èŠ‚ç‚¹
        if len(self.path) == len(nums):
            self.paths.append(self.path[:])
            return

        # å•å±‚é€’å½’é€»è¾‘
        for i in range(0, len(nums)):  # ä»å¤´å¼€å§‹æœç´¢
            # è‹¥é‡åˆ°self.pathé‡Œå·²æ”¶å½•çš„å…ƒç´ ï¼Œè·³è¿‡
            if usage_list[i] == True:
                continue
            usage_list[i] = True
            self.path.append(nums[i])
            self.backtracking(nums, usage_list)     # çºµå‘ä¼ é€’ä½¿ç”¨ä¿¡æ¯ï¼Œå»é‡
            self.path.pop()
            usage_list[i] = False

 # **å›æº¯+ä¸¢æ‰usage_list**
class Solution:
    def __init__(self):
        self.path = []
        self.paths = []

    def permute(self, nums: List[int]) -> List[List[int]]:
        '''
        å› ä¸ºæœ¬é¢˜æ’åˆ—æ˜¯æœ‰åºçš„ï¼Œè¿™æ„å‘³ç€åŒä¸€å±‚çš„å…ƒç´ å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä½†åŒä¸€æ ‘æä¸Šä¸èƒ½é‡å¤ä½¿ç”¨
        æ‰€ä»¥å¤„ç†æ’åˆ—é—®é¢˜æ¯å±‚éƒ½éœ€è¦ä»å¤´æœç´¢ï¼Œæ•…ä¸å†ä½¿ç”¨start_index
        '''
        self.backtracking(nums)
        return self.paths

    def backtracking(self, nums: List[int]) -> None:
        # Base Caseæœ¬é¢˜æ±‚å¶å­èŠ‚ç‚¹
        if len(self.path) == len(nums):
            self.paths.append(self.path[:])
            return

        # å•å±‚é€’å½’é€»è¾‘
        for i in range(0, len(nums)):  # ä»å¤´å¼€å§‹æœç´¢
            # è‹¥é‡åˆ°self.pathé‡Œå·²æ”¶å½•çš„å…ƒç´ ï¼Œè·³è¿‡
            if nums[i] in self.path:
                continue
            self.path.append(nums[i])
            self.backtracking(nums)
            self.path.pop()
```

* []

```Go
var (
    res [][]int
    path  []int
    st    []bool   // stateçš„ç¼©å†™
)
func permute(nums []int) [][]int {
    res, path = make([][]int, 0), make([]int, 0, len(nums))
    st = make([]bool, len(nums))
    dfs(nums, 0)
    return res
}

func dfs(nums []int, cur int) {
    if cur == len(nums) {
        tmp := make([]int, len(path))
        copy(tmp, path)
        res = append(res, tmp)
    }
    for i := 0; i < len(nums); i++ {
        if !st[i] {
            path = append(path, nums[i])
            st[i] = true
            dfs(nums, cur + 1)
            st[i] = false
            path = path[:len(path)-1]
        }
    }
}
```

* []

```js

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const res = [], path = [];
    backtracking(nums, nums.length, []);
    return res;
    
    function backtracking(n, k, used) {
        if(path.length === k) {
            res.push(Array.from(path));
            return;
        }
        for (let i = 0; i < k; i++ ) {
            if(used[i]) continue;
            path.push(n[i]);
            used[i] = true; // åŒæ”¯
            backtracking(n, k, used);
            path.pop();
            used[i] = false;
        }
    }
};

```

* []

```typescript
function permute(nums: number[]): number[][] {
    const resArr: number[][] = [];
    const helperSet: Set<number> = new Set();
    backTracking(nums, []);
    return resArr;
    function backTracking(nums: number[], route: number[]): void {
        if (route.length === nums.length) {
            resArr.push([...route]);
            return;
        }
        let tempVal: number;
        for (let i = 0, length = nums.length; i < length; i++) {
            tempVal = nums[i];
            if (!helperSet.has(tempVal)) {
                route.push(tempVal);
                helperSet.add(tempVal);
                backTracking(nums, route);
                route.pop();
                helperSet.delete(tempVal);
            }
        }
    }
};
```

* []

```Rust
impl Solution {
    fn backtracking(result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, nums: &Vec<i32>, used: &mut Vec<bool>) {
        let len = nums.len();
        if path.len() == len {
            result.push(path.clone());
            return;
        }
        for i in 0..len {
            if used[i] == true { continue; }
            used[i] = true;
            path.push(nums[i]);
            Self::backtracking(result, path, nums, used);
            path.pop();
            used[i] = false;
        }
    }

    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut path: Vec<i32> = Vec::new();
        let mut used = vec![false; nums.len()];
        Self::backtracking(&mut result, &mut path, &nums, &mut used);
        result
    }
}
```

* []

```c
int* path;
int pathTop;
int** ans;
int ansTop;

//å°†usedä¸­å…ƒç´ éƒ½è®¾ç½®ä¸º0
void initialize(int* used, int usedLength) {
    int i;
    for(i = 0; i < usedLength; i++) {
        used[i] = 0;
    }
}

//å°†pathä¸­å…ƒç´ æ‹·è´åˆ°ansä¸­
void copy() {
    int* tempPath = (int*)malloc(sizeof(int) * pathTop);
    int i;
    for(i = 0; i < pathTop; i++) {
        tempPath[i] = path[i];
    }
    ans[ansTop++] = tempPath;
}

void backTracking(int* nums, int numsSize, int* used) {
    //è‹¥pathä¸­å…ƒç´ ä¸ªæ•°ç­‰äºnumså…ƒç´ ä¸ªæ•°ï¼Œå°†numsæ”¾å…¥ansä¸­
    if(pathTop == numsSize) {
        copy();
        return;
    }
    int i;
    for(i = 0; i < numsSize; i++) {
        //è‹¥å½“å‰ä¸‹æ ‡ä¸­å…ƒç´ å·²ä½¿ç”¨è¿‡ï¼Œåˆ™è·³è¿‡å½“å‰å…ƒç´ 
        if(used[i])
            continue;
        used[i] = 1;
        path[pathTop++] = nums[i];
        backTracking(nums, numsSize, used);
        //å›æº¯
        pathTop--;
        used[i] = 0;
    }
}

int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //åˆå§‹åŒ–è¾…åŠ©å˜é‡
    path = (int*)malloc(sizeof(int) * numsSize);
    ans = (int**)malloc(sizeof(int*) * 1000);
    int* used = (int*)malloc(sizeof(int) * numsSize);
    //å°†usedæ•°ç»„ä¸­å…ƒç´ éƒ½ç½®0
    initialize(used, numsSize);
    ansTop = pathTop = 0;

    backTracking(nums, numsSize, used);

    //è®¾ç½®pathå’Œansæ•°ç»„çš„é•¿åº¦
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = numsSize;
    }
    return ans;
}
```

* []

```swift
func permute(_ nums: [Int]) -> [[Int]] {
    var result = [[Int]]()
    var path = [Int]()
    var used = [Bool](repeating: false, count: nums.count) // è®°å½•pathä¸­å·²åŒ…å«çš„å…ƒç´ 
    func backtracking() {
        // ç»“æŸæ¡ä»¶ï¼Œæ”¶é›†ç»“æœ
        if path.count == nums.count {
            result.append(path)
            return
        }

        for i in 0 ..< nums.count {
            if used[i] { continue } // æ’é™¤å·²åŒ…å«çš„å…ƒç´ 
            used[i] = true
            path.append(nums[i])
            backtracking()
            // å›æº¯
            path.removeLast()
            used[i] = false
        }
    }
    backtracking()
    return result
}
```

* []

```scala
object Solution {
  import scala.collection.mutable
  def permute(nums: Array[Int]): List[List[Int]] = {
    var result = mutable.ListBuffer[List[Int]]()
    var path = mutable.ListBuffer[Int]()

    def backtracking(used: Array[Boolean]): Unit = {
      if (path.size == nums.size) {
        // å¦‚æœpathçš„é•¿åº¦å’Œnumsç›¸ç­‰ï¼Œé‚£ä¹ˆå¯ä»¥æ·»åŠ åˆ°ç»“æœé›†
        result.append(path.toList)
        return
      }
      // æ·»åŠ å¾ªç¯å®ˆå«ï¼Œåªæœ‰å½“å½“å‰æ•°å­—æ²¡æœ‰ç”¨è¿‡çš„æƒ…å†µä¸‹æ‰è¿›å…¥å›æº¯
      for (i <- nums.indices if used(i) == false) {
        used(i) = true
        path.append(nums(i))
        backtracking(used) // å›æº¯
        path.remove(path.size - 1)
        used(i) = false
      }
    }

    backtracking(new Array[Boolean](nums.size)) // è°ƒç”¨æ–¹æ³•
    result.toList // æœ€ç»ˆè¿”å›ç»“æœé›†çš„Listå½¢å¼
  }
}
```

# å›æº¯ç®—æ³•åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ å›æº¯ç®—æ³•çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

* [å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)
* ç»„åˆé—®é¢˜
  * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
  * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
  * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
  * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
  * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜
  * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
  * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)
* å­é›†é—®é¢˜
  * [78.å­é›†](https://programmercarl.com/0078.å­é›†.html)
  * [90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)
* æ’åˆ—é—®é¢˜
  * [46.å…¨æ’åˆ—](https://programmercarl.com/0046.å…¨æ’åˆ—.html)
  * [47.å…¨æ’åˆ—II](https://programmercarl.com/0047.å…¨æ’åˆ—II.html)
* æ£‹ç›˜é—®é¢˜
  * [51.Nçš‡å](https://programmercarl.com/0051.Nçš‡å.html)
  * [37.è§£æ•°ç‹¬](https://programmercarl.com/0037.è§£æ•°ç‹¬.html)
* å…¶ä»–
  * [491.é€’å¢å­åºåˆ—](https://programmercarl.com/0491.é€’å¢å­åºåˆ—.html)
  * [332.é‡æ–°å®‰æ’è¡Œç¨‹](https://programmercarl.com/0332.é‡æ–°å®‰æ’è¡Œç¨‹.html)
* [å›æº¯ç®—æ³•æ€»ç»“ç¯‡](https://programmercarl.com/å›æº¯æ€»ç»“.html)

-----------

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

